#!/usr/bin/env python3
"""
Custom Platform Integration System
Advanced integration feature for adding new 3D asset platforms
"""

import os
import sys
import json
import logging
import importlib
import importlib.util
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
from abc import ABC, abstractmethod

# Add the config directory to the path
config_path = os.path.join(os.path.dirname(__file__), '..', 'config')
sys.path.insert(0, config_path)

try:
    from settings import CUSTOM_PLATFORM_SETTINGS, INTEGRATION_TEMPLATES
except ImportError:
    # Fallback configuration
    CUSTOM_PLATFORM_SETTINGS = {
        "template_directory": "templates",
        "plugin_directory": "plugins",
        "validation_enabled": True,
        "auto_discovery": True
    }
    INTEGRATION_TEMPLATES = {
        "basic": "basic_platform_template.py",
        "advanced": "advanced_platform_template.py",
        "api_based": "api_platform_template.py"
    }

logger = logging.getLogger(__name__)

class PlatformInterface(ABC):
    """Abstract base class for platform integrations"""
    
    @abstractmethod
    def search_assets(self, query: str, limit: int = 10) -> List[Dict]:
        """Search for assets on the platform"""
        pass
    
    @abstractmethod
    def download_asset(self, asset_info: Dict) -> Optional[str]:
        """Download an asset from the platform"""
        pass
    
    @abstractmethod
    def get_asset_details(self, asset_id: str) -> Dict:
        """Get detailed information about a specific asset"""
        pass
    
    @abstractmethod
    def authenticate(self, credentials: Dict) -> bool:
        """Authenticate with the platform"""
        pass
    
    @abstractmethod
    def get_platform_info(self) -> Dict:
        """Get platform information and capabilities"""
        pass

class CustomPlatformManager:
    """Manager for custom platform integrations"""
    
    def __init__(self):
        self.settings = CUSTOM_PLATFORM_SETTINGS
        self.templates = INTEGRATION_TEMPLATES
        self.registered_platforms = {}
        self.plugin_directory = Path(self.settings["plugin_directory"])
        self.template_directory = Path(self.settings["template_directory"])
        
        # Create directories if they don't exist
        self.plugin_directory.mkdir(parents=True, exist_ok=True)
        self.template_directory.mkdir(parents=True, exist_ok=True)
        
        # Auto-discover existing platforms
        if self.settings["auto_discovery"]:
            self.discover_platforms()
    
    def create_platform_integration(self, platform_name: str, template_type: str = "basic",
                                  custom_config: Optional[Dict] = None) -> str:
        """Create a new platform integration from template"""
        template_file = self.template_directory / self.templates[template_type]
        
        if not template_file.exists():
            # Create template if it doesn't exist
            self._create_template(template_type)
        
        # Generate platform integration code
        platform_code = self._generate_platform_code(platform_name, template_type, custom_config or {})

        # Save platform integration
        platform_file = self.plugin_directory / f"{platform_name.lower()}_integration.py"
        with open(platform_file, 'w') as f:
            f.write(platform_code)

        # Create platform configuration
        config_file = self.plugin_directory / f"{platform_name.lower()}_config.json"
        platform_config = self._create_platform_config(platform_name, custom_config or {})
        with open(config_file, 'w') as f:
            json.dump(platform_config, f, indent=2)
        
        logger.info(f"Created platform integration: {platform_name}")
        return str(platform_file)
    
    def _create_template(self, template_type: str):
        """Create integration template"""
        if template_type == "basic":
            template_content = self._get_basic_template()
        elif template_type == "advanced":
            template_content = self._get_advanced_template()
        elif template_type == "api_based":
            template_content = self._get_api_template()
        else:
            raise ValueError(f"Unknown template type: {template_type}")
        
        template_file = self.template_directory / f"{template_type}_platform_template.py"
        with open(template_file, 'w') as f:
            f.write(template_content)
    
    def _get_basic_template(self) -> str:
        """Get basic platform template"""
        return '''#!/usr/bin/env python3
"""
Basic Platform Integration Template
Generated by Custom Platform Manager
"""

import requests
import json
from typing import Dict, List, Optional
from custom_platform_integration import PlatformInterface

class {PLATFORM_NAME}Integration(PlatformInterface):
    """Integration for {PLATFORM_NAME} platform"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.base_url = config.get("base_url", "")
        self.api_key = config.get("api_key", "")
        self.session = requests.Session()
        
        # Set up authentication headers
        if self.api_key:
            self.session.headers.update({{"Authorization": f"Bearer {self.api_key}"}})
    
    def search_assets(self, query: str, limit: int = 10) -> List[Dict]:
        """Search for assets on the platform"""
        try:
            # Implement search logic here
            response = self.session.get(
                f"{self.base_url}/search",
                params={{"q": query, "limit": limit}}
            )
            response.raise_for_status()
            
            data = response.json()
            return data.get("assets", [])
            
        except Exception as e:
            print(f"Search failed: {e}")
            return []
    
    def download_asset(self, asset_info: Dict) -> Optional[str]:
        """Download an asset from the platform"""
        try:
            asset_id = asset_info.get("id")
            download_url = asset_info.get("download_url")
            
            if not download_url:
                print(f"No download URL for asset {asset_id}")
                return None
            
            # Download the asset
            response = self.session.get(download_url)
            response.raise_for_status()
            
            # Save to file
            filename = f"{asset_id}.{asset_info.get('format', 'fbx')}"
            filepath = f"/tmp/{filename}"
            
            with open(filepath, 'wb') as f:
                f.write(response.content)
            
            return filepath
            
        except Exception as e:
            print(f"Download failed: {e}")
            return None
    
    def get_asset_details(self, asset_id: str) -> Dict:
        """Get detailed information about a specific asset"""
        try:
            response = self.session.get(f"{self.base_url}/assets/{asset_id}")
            response.raise_for_status()
            
            return response.json()
            
        except Exception as e:
            print(f"Failed to get asset details: {e}")
            return {{}}
    
    def authenticate(self, credentials: Dict) -> bool:
        """Authenticate with the platform"""
        try:
            # Implement authentication logic here
            self.api_key = credentials.get("api_key", "")
            if self.api_key:
                self.session.headers.update({{"Authorization": f"Bearer {self.api_key}"}})
                return True
            return False
            
        except Exception as e:
            print(f"Authentication failed: {e}")
            return False
    
    def get_platform_info(self) -> Dict:
        """Get platform information and capabilities"""
        return {{
            "name": "{PLATFORM_NAME}",
            "version": "1.0.0",
            "capabilities": ["search", "download", "authentication"],
            "supported_formats": [".fbx", ".obj", ".blend"],
            "rate_limit": 1000,
            "requires_auth": True
        }}
'''
    
    def _get_advanced_template(self) -> str:
        """Get advanced platform template"""
        return '''#!/usr/bin/env python3
"""
Advanced Platform Integration Template
Generated by Custom Platform Manager
"""

import requests
import json
import time
from typing import Dict, List, Optional
from custom_platform_integration import PlatformInterface

class {PLATFORM_NAME}Integration(PlatformInterface):
    """Advanced integration for {PLATFORM_NAME} platform"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.base_url = config.get("base_url", "")
        self.api_key = config.get("api_key", "")
        self.session = requests.Session()
        self.rate_limit_delay = config.get("rate_limit_delay", 1.0)
        self.last_request_time = 0
        
        # Set up authentication headers
        if self.api_key:
            self.session.headers.update({{"Authorization": f"Bearer {self.api_key}"}})
    
    def _rate_limit(self):
        """Implement rate limiting"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        if time_since_last < self.rate_limit_delay:
            time.sleep(self.rate_limit_delay - time_since_last)
        self.last_request_time = time.time()
    
    def search_assets(self, query: str, limit: int = 10) -> List[Dict]:
        """Search for assets with advanced filtering"""
        self._rate_limit()
        
        try:
            # Advanced search with filters
            params = {{
                "q": query,
                "limit": limit,
                "sort": "relevance",
                "filters": json.dumps({{
                    "price_range": self.config.get("price_range", [0, 1000]),
                    "quality_min": self.config.get("quality_min", 3.0),
                    "formats": self.config.get("supported_formats", [])
                }})
            }}
            
            response = self.session.get(f"{self.base_url}/search", params=params)
            response.raise_for_status()
            
            data = response.json()
            return self._process_search_results(data.get("assets", []))
            
        except Exception as e:
            print(f"Advanced search failed: {e}")
            return []
    
    def _process_search_results(self, assets: List[Dict]) -> List[Dict]:
        """Process and enhance search results"""
        processed_assets = []
        for asset in assets:
            # Add computed fields
            asset["computed_quality"] = self._compute_quality_score(asset)
            asset["download_priority"] = self._compute_download_priority(asset)
            processed_assets.append(asset)
        
        return processed_assets
    
    def _compute_quality_score(self, asset: Dict) -> float:
        """Compute quality score for asset"""
        rating = asset.get("rating", 0)
        downloads = asset.get("downloads", 0)
        reviews = asset.get("reviews", 0)
        
        # Weighted quality score
        quality_score = (rating * 0.5) + (min(downloads / 1000, 1.0) * 0.3) + (min(reviews / 100, 1.0) * 0.2)
        return min(quality_score, 5.0)
    
    def _compute_download_priority(self, asset: Dict) -> int:
        """Compute download priority for asset"""
        quality_score = self._compute_quality_score(asset)
        price = asset.get("price", 0)
        
        # Higher quality and lower price = higher priority
        priority = int(quality_score * 10) - int(price / 10)
        return max(priority, 1)
    
    def download_asset(self, asset_info: Dict) -> Optional[str]:
        """Download asset with progress tracking"""
        try:
            asset_id = asset_info.get("id")
            download_url = asset_info.get("download_url")
            
            if not download_url:
                print(f"No download URL for asset {asset_id}")
                return None
            
            self._rate_limit()
            
            # Download with progress tracking
            response = self.session.get(download_url, stream=True)
            response.raise_for_status()
            
            # Save to file with progress
            filename = f"{asset_id}.{asset_info.get('format', 'fbx')}"
            filepath = f"/tmp/{filename}"
            
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            
            with open(filepath, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            progress = (downloaded / total_size) * 100
                            print(f"Download progress: {{progress:.1f}}%")
            
            return filepath
            
        except Exception as e:
            print(f"Download failed: {e}")
            return None
    
    def get_asset_details(self, asset_id: str) -> Dict:
        """Get comprehensive asset details"""
        self._rate_limit()
        
        try:
            response = self.session.get(f"{self.base_url}/assets/{asset_id}")
            response.raise_for_status()
            
            asset_data = response.json()
            
            # Enhance with additional data
            asset_data["quality_score"] = self._compute_quality_score(asset_data)
            asset_data["download_priority"] = self._compute_download_priority(asset_data)
            asset_data["compatibility"] = self._check_compatibility(asset_data)
            
            return asset_data
            
        except Exception as e:
            print(f"Failed to get asset details: {e}")
            return {{}}
    
    def _check_compatibility(self, asset: Dict) -> Dict:
        """Check asset compatibility with Blender"""
        formats = asset.get("formats", [])
        blender_formats = [".blend", ".fbx", ".obj", ".dae", ".gltf"]
        
        compatible_formats = [fmt for fmt in formats if fmt in blender_formats]
        
        return {{
            "is_compatible": len(compatible_formats) > 0,
            "compatible_formats": compatible_formats,
            "compatibility_score": len(compatible_formats) / len(blender_formats)
        }}
    
    def authenticate(self, credentials: Dict) -> bool:
        """Advanced authentication with validation"""
        try:
            self.api_key = credentials.get("api_key", "")
            if not self.api_key:
                return False
            
            # Test authentication
            self.session.headers.update({{"Authorization": f"Bearer {self.api_key}"}})
            response = self.session.get(f"{self.base_url}/auth/validate")
            response.raise_for_status()
            
            auth_data = response.json()
            self.config.update(auth_data.get("user_info", {{}}))
            
            return True
            
        except Exception as e:
            print(f"Authentication failed: {e}")
            return False
    
    def get_platform_info(self) -> Dict:
        """Get comprehensive platform information"""
        return {{
            "name": "{PLATFORM_NAME}",
            "version": "2.0.0",
            "capabilities": [
                "search", "download", "authentication", "rate_limiting",
                "quality_scoring", "compatibility_checking", "progress_tracking"
            ],
            "supported_formats": [".fbx", ".obj", ".blend", ".dae", ".gltf"],
            "rate_limit": 1000,
            "requires_auth": True,
            "advanced_features": True
        }}
'''
    
    def _get_api_template(self) -> str:
        """Get API-based platform template"""
        return '''#!/usr/bin/env python3
"""
API-Based Platform Integration Template
Generated by Custom Platform Manager
"""

import requests
import json
from typing import Dict, List, Optional
from custom_platform_integration import PlatformInterface

class {PLATFORM_NAME}Integration(PlatformInterface):
    """API-based integration for {PLATFORM_NAME} platform"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.api_base_url = config.get("api_base_url", "")
        self.api_key = config.get("api_key", "")
        self.api_version = config.get("api_version", "v1")
        self.session = requests.Session()
        
        # Set up API headers
        headers = {{
            "Content-Type": "application/json",
            "Accept": "application/json"
        }}
        
        if self.api_key:
            headers["X-API-Key"] = self.api_key
        
        self.session.headers.update(headers)
    
    def search_assets(self, query: str, limit: int = 10) -> List[Dict]:
        """Search assets using platform API"""
        try:
            endpoint = f"{self.api_base_url}/{self.api_version}/search"
            payload = {{
                "query": query,
                "limit": limit,
                "filters": self.config.get("search_filters", {{}})
            }}
            
            response = self.session.post(endpoint, json=payload)
            response.raise_for_status()
            
            data = response.json()
            return data.get("results", [])
            
        except Exception as e:
            print(f"API search failed: {e}")
            return []
    
    def download_asset(self, asset_info: Dict) -> Optional[str]:
        """Download asset using platform API"""
        try:
            asset_id = asset_info.get("id")
            endpoint = f"{self.api_base_url}/{self.api_version}/assets/{asset_id}/download"
            
            response = self.session.get(endpoint)
            response.raise_for_status()
            
            # Get download URL from API response
            download_data = response.json()
            download_url = download_data.get("download_url")
            
            if not download_url:
                print(f"No download URL from API for asset {asset_id}")
                return None
            
            # Download the actual file
            file_response = self.session.get(download_url)
            file_response.raise_for_status()
            
            # Save to file
            filename = f"{asset_id}.{asset_info.get('format', 'fbx')}"
            filepath = f"/tmp/{filename}"
            
            with open(filepath, 'wb') as f:
                f.write(file_response.content)
            
            return filepath
            
        except Exception as e:
            print(f"API download failed: {e}")
            return None
    
    def get_asset_details(self, asset_id: str) -> Dict:
        """Get asset details using platform API"""
        try:
            endpoint = f"{self.api_base_url}/{self.api_version}/assets/{asset_id}"
            
            response = self.session.get(endpoint)
            response.raise_for_status()
            
            return response.json()
            
        except Exception as e:
            print(f"Failed to get asset details from API: {e}")
            return {{}}
    
    def authenticate(self, credentials: Dict) -> bool:
        """Authenticate using platform API"""
        try:
            self.api_key = credentials.get("api_key", "")
            if not self.api_key:
                return False
            
            # Test API authentication
            endpoint = f"{self.api_base_url}/{self.api_version}/auth/verify"
            headers = {{"X-API-Key": self.api_key}}
            
            response = self.session.get(endpoint, headers=headers)
            response.raise_for_status()
            
            auth_data = response.json()
            self.config.update(auth_data.get("user", {{}}))
            
            return True
            
        except Exception as e:
            print(f"API authentication failed: {e}")
            return False
    
    def get_platform_info(self) -> Dict:
        """Get platform information from API"""
        try:
            endpoint = f"{self.api_base_url}/{self.api_version}/info"
            response = self.session.get(endpoint)
            response.raise_for_status()
            
            return response.json()
            
        except Exception as e:
            print(f"Failed to get platform info from API: {e}")
            return {{
                "name": "{PLATFORM_NAME}",
                "version": "1.0.0",
                "capabilities": ["api_based"],
                "supported_formats": [".fbx", ".obj", ".blend"],
                "rate_limit": 1000,
                "requires_auth": True
            }}
'''
    
    def _generate_platform_code(self, platform_name: str, template_type: str, custom_config: Dict) -> str:
        """Generate platform integration code from template"""
        template_file = self.template_directory / f"{template_type}_platform_template.py"
        
        with open(template_file, 'r') as f:
            template_content = f.read()
        
        # Replace placeholders
        platform_code = template_content.replace("{PLATFORM_NAME}", platform_name)
        
        # Add custom configuration if provided
        if custom_config:
            config_section = f"""
# Custom configuration
CUSTOM_CONFIG = {json.dumps(custom_config, indent=4)}
"""
            platform_code += config_section
        
        return platform_code
    
    def _create_platform_config(self, platform_name: str, custom_config: Dict) -> Dict:
        """Create platform configuration"""
        base_config = {
            "platform_name": platform_name,
            "version": "1.0.0",
            "enabled": True,
            "priority": 1,
            "rate_limit": 1000,
            "timeout": 30,
            "retry_attempts": 3
        }
        
        if custom_config:
            base_config.update(custom_config)
        
        return base_config
    
    def register_platform(self, platform_name: str, integration_class: type) -> bool:
        """Register a platform integration"""
        try:
            self.registered_platforms[platform_name] = integration_class
            logger.info(f"Registered platform: {platform_name}")
            return True
        except Exception as e:
            logger.error(f"Failed to register platform {platform_name}: {e}")
            return False
    
    def load_platform(self, platform_name: str) -> Optional[PlatformInterface]:
        """Load a platform integration"""
        try:
            # Try to load from registered platforms first
            if platform_name in self.registered_platforms:
                return self.registered_platforms[platform_name]
            
            # Try to load from plugin directory
            plugin_file = self.plugin_directory / f"{platform_name.lower()}_integration.py"
            if plugin_file.exists():
                spec = importlib.util.spec_from_file_location(
                    f"{platform_name.lower()}_integration",
                    plugin_file
                )
                if spec is None or spec.loader is None:
                    logger.error(f"Could not create module spec for {plugin_file}")
                    return None

                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Get the integration class
                class_name = f"{platform_name}Integration"
                if hasattr(module, class_name):
                    integration_class = getattr(module, class_name)
                    return integration_class
                else:
                    logger.error(f"Integration class {class_name} not found in {plugin_file}")
                    return None
            else:
                logger.error(f"Platform integration file not found: {plugin_file}")
                return None
                
        except Exception as e:
            logger.error(f"Failed to load platform {platform_name}: {e}")
            return None
    
    def discover_platforms(self) -> List[str]:
        """Auto-discover available platform integrations"""
        discovered_platforms = []
        
        for plugin_file in self.plugin_directory.glob("*_integration.py"):
            platform_name = plugin_file.stem.replace("_integration", "")
            discovered_platforms.append(platform_name)
            
            # Try to load the platform
            try:
                integration = self.load_platform(platform_name)
                if integration:
                    self.register_platform(platform_name, integration.__class__)
            except Exception as e:
                logger.warning(f"Failed to load discovered platform {platform_name}: {e}")
        
        logger.info(f"Discovered {len(discovered_platforms)} platforms: {discovered_platforms}")
        return discovered_platforms
    
    def validate_platform_integration(self, platform_name: str) -> Dict[str, Any]:
        """Validate a platform integration"""
        validation_results: Dict[str, Any] = {
            "platform_name": platform_name,
            "valid": True,
            "errors": [],
            "warnings": [],
            "capabilities": []
        }
        
        try:
            integration = self.load_platform(platform_name)
            if not integration:
                validation_results["valid"] = False
                validation_results["errors"].append("Failed to load platform integration")
                return validation_results
            
            # Test required methods
            required_methods = ["search_assets", "download_asset", "get_asset_details", "authenticate", "get_platform_info"]
            for method_name in required_methods:
                if not hasattr(integration, method_name):
                    validation_results["valid"] = False
                    validation_results["errors"].append(f"Missing required method: {method_name}")
            
            # Test platform info
            try:
                platform_info = integration.get_platform_info()
                validation_results["capabilities"] = platform_info.get("capabilities", [])
            except Exception as e:
                validation_results["warnings"].append(f"Failed to get platform info: {e}")
            
            # Test authentication (if credentials available)
            try:
                test_credentials = {"api_key": "test_key"}
                auth_result = integration.authenticate(test_credentials)
                if not auth_result:
                    validation_results["warnings"].append("Authentication test failed (expected for test credentials)")
            except Exception as e:
                validation_results["warnings"].append(f"Authentication test failed: {e}")
            
        except Exception as e:
            validation_results["valid"] = False
            validation_results["errors"].append(f"Validation failed: {e}")
        
        return validation_results
    
    def get_available_platforms(self) -> List[Dict]:
        """Get list of available platforms with their status"""
        platforms = []
        
        for platform_name in self.registered_platforms.keys():
            validation = self.validate_platform_integration(platform_name)
            platforms.append({
                "name": platform_name,
                "status": "valid" if validation["valid"] else "invalid",
                "capabilities": validation["capabilities"],
                "errors": validation["errors"],
                "warnings": validation["warnings"]
            })
        
        return platforms

def main():
    """Main function to demonstrate custom platform integration"""
    print("🔧 Custom Platform Integration System")
    print("=" * 50)
    
    # Initialize custom platform manager
    manager = CustomPlatformManager()
    
    # Create a sample platform integration
    print("\n📝 Creating sample platform integration...")
    custom_config = {
        "base_url": "https://api.example-platform.com",
        "api_key": "your_api_key_here",
        "rate_limit": 500,
        "supported_formats": [".fbx", ".obj", ".blend", ".dae"]
    }
    
    platform_file = manager.create_platform_integration(
        "ExamplePlatform", 
        "basic", 
        custom_config
    )
    print(f"Created platform integration: {platform_file}")
    
    # Discover platforms
    print("\n🔍 Discovering platforms...")
    discovered = manager.discover_platforms()
    print(f"Discovered platforms: {discovered}")
    
    # Load and test platform
    print("\n🧪 Testing platform integration...")
    integration = manager.load_platform("exampleplatform")
    if integration:
        print("✅ Platform integration loaded successfully")
        
        # Test platform info
        platform_info = integration.get_platform_info()
        print(f"Platform info: {platform_info}")
        
        # Validate integration
        validation = manager.validate_platform_integration("exampleplatform")
        print(f"Validation results: {validation}")
    else:
        print("❌ Failed to load platform integration")
    
    # Get available platforms
    print("\n📋 Available platforms:")
    platforms = manager.get_available_platforms()
    for platform in platforms:
        print(f"  - {platform['name']}: {platform['status']}")
        if platform['errors']:
            print(f"    Errors: {platform['errors']}")
        if platform['warnings']:
            print(f"    Warnings: {platform['warnings']}")
    
    print("\n✅ Custom platform integration system ready!")

if __name__ == "__main__":
    main()
